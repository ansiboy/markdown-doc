{"version":3,"sources":["../out/assign-deep.js"],"names":["getTypeOf","input","Array","isArray","cloneValue","value","quickCloneObject","quickCloneArray","map","output","key","hasOwnProperty","executeDeepMerge","target","_objects","_options","options","arrayBehaviour","objects","object","oindex","length","keys","Object","kindex","type","existingValueType","existingValue","newValue","concat","objectAssignDeep","objectAssignDeepInto","withOptions"],"mappings":"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","sourcesContent":["'use strict';\r\n/*\r\n * OBJECT ASSIGN DEEP\r\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\r\n */\r\n/*\r\n * A unified way of returning a string that describes the type of the given variable.\r\n */\r\nfunction getTypeOf(input) {\r\n    if (input === null) {\r\n        return 'null';\r\n    }\r\n    else if (typeof input === 'undefined') {\r\n        return 'undefined';\r\n    }\r\n    else if (typeof input === 'object') {\r\n        return (Array.isArray(input) ? 'array' : 'object');\r\n    }\r\n    return typeof input;\r\n}\r\n/*\r\n * Branching logic which calls the correct function to clone the given value base on its type.\r\n */\r\nfunction cloneValue(value) {\r\n    // The value is an object so lets clone it.\r\n    if (getTypeOf(value) === 'object') {\r\n        return quickCloneObject(value);\r\n    }\r\n    // The value is an array so lets clone it.\r\n    else if (getTypeOf(value) === 'array') {\r\n        return quickCloneArray(value);\r\n    }\r\n    // Any other value can just be copied.\r\n    return value;\r\n}\r\n/*\r\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\r\n */\r\nfunction quickCloneArray(input) {\r\n    return input.map(cloneValue);\r\n}\r\n/*\r\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\r\n * its values cloned (i.e. references broken).\r\n */\r\nfunction quickCloneObject(input) {\r\n    const output = {};\r\n    for (const key in input) {\r\n        if (!input.hasOwnProperty(key)) {\r\n            continue;\r\n        }\r\n        output[key] = cloneValue(input[key]);\r\n    }\r\n    return output;\r\n}\r\n/*\r\n * Does the actual deep merging.\r\n */\r\nfunction executeDeepMerge(target, _objects = [], _options = {}) {\r\n    const options = {\r\n        arrayBehaviour: _options.arrayBehaviour || 'replace',\r\n    };\r\n    // Ensure we have actual objects for each.\r\n    const objects = _objects.map(object => object || {});\r\n    const output = target || {};\r\n    // Enumerate the objects and their keys.\r\n    for (let oindex = 0; oindex < objects.length; oindex++) {\r\n        const object = objects[oindex];\r\n        const keys = Object.keys(object);\r\n        for (let kindex = 0; kindex < keys.length; kindex++) {\r\n            const key = keys[kindex];\r\n            const value = object[key];\r\n            const type = getTypeOf(value);\r\n            const existingValueType = getTypeOf(output[key]);\r\n            if (type === 'object') {\r\n                if (existingValueType !== 'undefined') {\r\n                    const existingValue = (existingValueType === 'object' ? output[key] : {});\r\n                    output[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\r\n                }\r\n                else {\r\n                    output[key] = quickCloneObject(value);\r\n                }\r\n            }\r\n            else if (type === 'array') {\r\n                if (existingValueType === 'array') {\r\n                    const newValue = quickCloneArray(value);\r\n                    output[key] = (options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue);\r\n                }\r\n                else {\r\n                    output[key] = quickCloneArray(value);\r\n                }\r\n            }\r\n            else {\r\n                output[key] = value;\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}\r\n/*\r\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\r\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\r\n * Properties in later objects will always overwrite.\r\n */\r\nexport function objectAssignDeep(target, ...objects) {\r\n    return executeDeepMerge(target, objects);\r\n}\r\n;\r\n/*\r\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\r\n */\r\nexport function objectAssignDeepInto(...objects) {\r\n    return executeDeepMerge({}, objects);\r\n}\r\n;\r\n/*\r\n * Allows an options object to be passed in to customise the behaviour of the function.\r\n */\r\nexport let withOptions = function objectAssignDeepInto(target, objects, options) {\r\n    return executeDeepMerge(target, objects, options);\r\n};\r\n"],"file":"assign-deep.js"}